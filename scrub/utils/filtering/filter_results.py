import os
import re
import logging
from scrub.utils import translate_results


def invalid_tag_check(source_file, warning_line, raw_valid_warning_types):
    """This function checks to see if there are any invalid tags on the line of interest.

    Inputs:
        - source_file: Absolute path to the source code file of interest [string]
        - warning_line: Line of interest of source code file [int]
        - raw_valid_warning_types: List of lists containing valid types for each tool [list of list of strings]

    Outputs:
        - invalid_type: Indicator if an invalid tag type was found [bool]
    """

    # Initialize variables
    ignore_base = "scrub_ignore_warning"
    valid_warning_types = []
    invalid_type = True

    # Get the types of interest
    for valid_type_set in raw_valid_warning_types:
        valid_warning_types = valid_warning_types + valid_type_set

    # Remove duplicates
    valid_warning_types = list(set(valid_warning_types))

    # Open the file of interest and read the lines
    with open(source_file, 'r') as fh:
        source_data = fh.readlines()

    # Get the line of interest from the file
    line = source_data[warning_line - 1]

    # Check to see if an invalid suppression tag exists
    if (ignore_base in line.lower()) or ('@suppress' in line.lower()):
        for check_type in valid_warning_types:
            if check_type in line.lower():
                invalid_type = False
    else:
        invalid_type = False

    return invalid_type


def micro_filter_check(source_file, warning_line, warning_type, raw_valid_warning_types):
    """This function checks to see if a warning has been marked as a false positive by the user.

    Inputs:
        - source_file: Absolute path to the source code file of interest [string]
        - warning_line: Line of interest of source code file [int]
        - warning_type: Full and accurate name of the check that should be ignored [string]
        - raw_valid_warning_types: List of lists containing valid types for each tool [list of list of strings]

    Outputs:
        - ignore_line: Indicator if warning should be ignored [bool]
    """

    # Set the base string
    ignore_base = "scrub_ignore_warning"

    # Initialize the return value
    ignore_line = False

    # Get the types of interest
    tool_warning_types = []
    for valid_type_set in raw_valid_warning_types:
        if warning_type in valid_type_set:
            tool_warning_types = tool_warning_types + valid_type_set

    try:
        # Open the file of interest and read the lines
        with open(source_file, 'r') as fh:
            source_data = fh.readlines()

        # Get the line of interest from the file
        line = source_data[warning_line - 1]

        # Check to see if the line should be filtered out
        if (ignore_base in line.lower()) or ('@suppress' in line.lower()):
            if any(check_type in line.lower() for check_type in tool_warning_types):
                ignore_line = True

                # Print a status message
                logging.debug('\tWarning removed - Warning has been marked as a false positive')
                logging.debug('\t\t%s', line)

    except IOError:
        logging.warning('\t\tMicro-filter warning')
        logging.warning('\t\tFile %s could not be found.', source_file)

    # Return value
    return ignore_line


def ignore_query_check(warning_tool, warning_query, ignore_queries_file):
    """This function checks if a result should be skipped based on the type of query.

    Inputs:
        - line: Line of interest from SCRUB results [string]
        - ignore_queries_file: Full path to the SCRUBExcludeQueries file [string]

    Outputs:
        - skip: Indicator if result should be filtered out [bool]
    """

    # Initialize the variables
    skip = False

    # Import the ignore data
    if os.path.isfile(ignore_queries_file):
        ignore_fh = open(ignore_queries_file, 'r')
        ignore_queries = ignore_fh.readlines()
        ignore_fh.close()

        # Iterate through every line of the ignore data
        for ignore_line in ignore_queries:
            # Split the line and store the values
            ignore_line_split = list(filter(None, re.split(':', ignore_line.strip())))
            ignore_tool = ignore_line_split[0].strip().lower()
            ignore_query = ignore_line_split[1].strip()

            # Determine if the ine should be skipped
            if (ignore_tool == warning_tool) and (ignore_query == warning_query):
                skip = True

                # Print a status message
                logging.debug('\tWarning removed - Warning generated by a filtered query')
                logging.debug('\t\t%s: %s', warning_tool, warning_query)

    return skip


def external_warning_check(warning_file, source_root):
    """This function checks to see if a warning originates outside the source code directory.

    Inputs:
        - warning_file:
        - source_root: Full path to the top level directory of the source code [string]

    Outputs:
        - skip: Indicator if result should be filtered out [bool]
    """

    # Check to see if the file exists outside the source root
    if not warning_file.startswith(source_root):
        skip = True

        # Print a status message
        logging.debug('\tWarning removed - Warning occurs in a file that is outside the source root')
        logging.debug('\t\t%s', warning_file)
    else:
        skip = False

    return skip


def baseline_filtering_check(warning_file, filtering_file):
    """This function checks to see if a warning occurs in a directory or file that should be ignored.

    Inputs:
        - warning_file: File of interest from warning data [string]
        - filtering_file: Absolute path to the SCRUBAnalysisFilteringList file [string]

    Outputs:
        - skip: Indicator if result should be filtered out [bool]
    """

    # Initialize the variables
    skip = True

    if os.path.isfile(filtering_file):
        # Import the ignore data
        with open(filtering_file, 'r') as input_fh:
            filtering_data = input_fh.readlines()

        # Iterate through every line of the ignore data
        for filter_file in filtering_data:
            if filter_file.strip() in warning_file:
                skip = False
                break

    # Print a status message
    if skip:
        logging.debug('\tWarning removed - Warning occurs in a file that has been excluded from analysis')
        logging.debug('\t\t%s', warning_file)

    return skip


def check_filtering_file(filtering_file, create):
    """This function checks the filtering file to see if it exists.

    Inputs:
        - filtering_file: Full path to the filtering file to be checked [string]
        - create: Flag to indicate if the file should be created if it doesn't exist [bool]
    """

    # Check to see if all the files exist
    if not os.path.isfile(filtering_file):
        logging.info('No %s file exists.', filtering_file)

        # Create the file if necessary
        if create:
            logging.info('\tCreating blank filtering file %s.', filtering_file)
            logging.info('\tPlease add filtering patterns to this file.')
            open(filtering_file, 'w+').close()


def duplicate_check(warning, warning_log):
    """This function checks to make sure that the warning has not been reported before.

    Inputs:
        - warning: current warning to be checked [string]
        - warning_log: log containing all warnings written previously [list of strings]

    Outputs:
        - skip: Indicator if result should be filtered out [bool]
    """

    # Initialize the variables
    skip = False

    # Check if the waring has been written out before
    if warning in warning_log:
        skip = True

    return skip


def filter_results(warning_list, output_file, filtering_file, ignore_query_file, source_root, enable_micro_filtering,
                   enable_external_warnings, valid_warning_types):
    """This function performs the filtering, including all other filtering functions.

    Inputs:
        - input_files: List of absolute paths to the input file(s) of interest [list of string]
        - output_file: Absolute path to file where filtered results will be stored [string]
        - filtering_file: Absolute path to the SCRUBAnalayisFilteringList file [string]
        - ignore_query_file: Absolute path to the SCRUBExcludeQueries file [string]
        - source_root: Absolute path to the top level directory of the source code [string]
        - enable_micro_filtering: Flag to enable/disable micro filtering [logical]
        - enable_external_warnings: Flag to enable/disable external warnings [logical]
        - valid_warning_types: List of lists that contain valid warning type tags [list of lists]

    Outputs:
        - output_file: All filtered results are written to the output_file
    """

    # Initialize the variables
    filtered_warnings = warning_list.copy()
    invalid_tag_log = []

    # Print a log message
    logging.info('')
    logging.info('\tFiltering results...')
    logging.info('\t>> Executing command: filter_results.filter_results(<warning_list>, %s, %s, %s, %s, %r, %r)',
                 output_file, filtering_file, ignore_query_file, source_root, enable_micro_filtering,
                 enable_external_warnings)
    logging.info('\t>> From directory: %s', os.getcwd())

    # Update the source root to make it absolute
    source_root = os.path.abspath(source_root)

    # Iterate through every warning in the list
    for warning in warning_list:
        # Check to see if it should be ignored
        baseline_filtering_result = baseline_filtering_check(warning['file'], filtering_file)

        # Check to see if the query should be ignore
        ignore_query_result = ignore_query_check(warning['tool'], warning['query'], ignore_query_file)

        # Check to see if the warning is external to the source directory
        if enable_external_warnings:
            external_check_result = False
        else:
            external_check_result = external_warning_check(warning['file'], source_root)

        # Check to see if a valid tag exists
        invalid_tag = invalid_tag_check(warning['file'], warning['line'], valid_warning_types)

        # Print a warning message if applicable
        if invalid_tag and ((warning['file'], warning['line']) not in invalid_tag_log):
            # Add the line to the list
            invalid_tag_log.append((warning['file'], warning['line']))

            # Print a waning message
            logging.warning('\t\tInvalid tool suppression selection on line %s of file %s',
                            str(warning['line']), warning['file'])

        # Perform micro filtering checking
        if enable_micro_filtering and not external_check_result and not invalid_tag:
            micro_check_result = micro_filter_check(warning['file'], warning['line'], warning['tool'],
                                                    valid_warning_types)
        else:
            micro_check_result = False

        # Or them together
        skip = baseline_filtering_result or ignore_query_result or external_check_result or micro_check_result

        # Remove the warning from the list, if necessary
        if skip:
            filtered_warnings.remove(warning)
        else:
            # Make the warning file path relative
            filtered_warnings[filtered_warnings.index(warning)]['file'] = warning['file'].replace(os.path.normpath(source_root) + '/', '')

    # Remove duplicates
    # filtered_warnings = list(set(filtered_warnings))

    # Write out the results
    translate_results.create_scrub_output_file(filtered_warnings, output_file)
